// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console} from "forge-std/Test.sol";
import {Groth16VerifierWrapper} from "../../src/contracts/Groth16VerifierWrapper.sol";
import {Groth16Verifier} from "../../src/contracts/generated/verifier.sol";

contract Groth16VerifierWrapperTest is Test {
    Groth16VerifierWrapper wrapper;
    Groth16Verifier groth16Verifier;

    function setUp() public {
        // Deploy the official Groth16Verifier
        groth16Verifier = new Groth16Verifier();

        // Deploy the wrapper
        wrapper = new Groth16VerifierWrapper(address(groth16Verifier));
    }

    function test_wrapper_should_delegate_to_groth16_verifier() public {
        // Sample proof data (this would normally come from snarkjs)
        uint[2] memory pA = [uint(1), uint(2)];
        uint[2][2] memory pB = [[uint(3), uint(4)], [uint(5), uint(6)]];
        uint[2] memory pC = [uint(7), uint(8)];
        uint[5] memory pubSignals = [uint(9), uint(10), uint(11), uint(12), uint(13)];

        // Test that wrapper delegates correctly
        // Note: This proof data is dummy and will likely fail verification
        // In real usage, you'd use actual proof data generated by snarkjs
        bool result = wrapper.verifyProof(pA, pB, pC, pubSignals);

        // The result depends on the actual proof data, but the call should work
        // This test mainly verifies that the delegation works without errors
        assertTrue(result == true || result == false, "Verification should return boolean");
    }

    function test_wrapper_should_store_correct_groth16_verifier_address() public {
        address storedAddress = address(wrapper.groth16Verifier());
        assertEq(storedAddress, address(groth16Verifier), "Should store correct Groth16Verifier address");
    }

    function test_constructor_should_revert_on_zero_address() public {
        vm.expectRevert("Invalid verifier address");
        new Groth16VerifierWrapper(address(0));
    }
}
